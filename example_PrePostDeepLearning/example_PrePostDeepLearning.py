import numpy as np

#################
# PREPROCESSING #
#################

# Read the solution generated by a physical computer code
from BasicTools.IO import XdmfReader as XR
reader = XR.XdmfReader(filename = "solution.xmf")
reader.Read()

dom = reader.xdmf.GetDomain(0)
grid = dom.GetGrid(0)


# Read the mesh
unstructuredMesh = grid.GetSupport()
for _,el in unstructuredMesh.elements.items():
    el.connectivity = np.asarray(el.connectivity, dtype=int)

# Read the solution field 'U'
indexU = grid.GetPointFieldsNames().index("U")
U = grid.GetPointFields()[indexU][:,0:2]


# Create a rectilinear mesh of size 48*48 excluding the left part of the mesh (x<0) 
Nx = 48
Ny = 48

unstructuredMesh.ComputeBoundingBox()

Lx = unstructuredMesh.boundingMax[0] - 0.
Ly = unstructuredMesh.boundingMax[1] - unstructuredMesh.boundingMin[1]  

from BasicTools.Containers.ConstantRectilinearMesh import ConstantRectilinearMesh    
rectMesh = ConstantRectilinearMesh(dim=2)
rectMesh.SetDimensions([Nx,Ny])
rectMesh.SetSpacing([Lx/(Nx-1), Ly/(Ny-1)])
rectMesh.SetOrigin([0.,unstructuredMesh.boundingMin[1]])


# Compute the projection operator from unstructured mesh to structured mesh
from BasicTools.Containers.UnstructuredMeshCreationTools import CreateMeshFromConstantRectilinearMesh
from BasicTools.FE.FETools import PrepareFEComputation
from BasicTools.Containers.UnstructuredMeshFieldOperations import GetFieldTransferOp
from BasicTools.FE.Fields.FEField import FEField

unstructuredRectMesh = CreateMeshFromConstantRectilinearMesh(rectMesh)
space, numberings, _offset, _NGauss = PrepareFEComputation(unstructuredMesh, numberOfComponents = 2)
inputFEField = FEField(name="U",mesh=unstructuredMesh,space=space,numbering=numberings[0])
methods = ["Interp/Nearest","Nearest/Nearest","Interp/Clamp","Interp/Extrap","Interp/ZeroFill"]
method = methods[2]
operator, status = GetFieldTransferOp(inputFEField, unstructuredRectMesh.nodes, method = method, verbose=True)


# Compute the projected field on the structured mesh
projectedU = operator.dot(U)


# Export the structured mesh and projected field in xdmf format
from BasicTools.IO import XdmfWriter as XW
writer = XW.XdmfWriter('PreprocessedData.xdmf')
writer.SetHdf5(False)
writer.Open()
writer.Write(rectMesh,PointFields=[projectedU.reshape((Nx,Ny,2))], PointFieldsNames=["U"]);
writer.Close()



##################
# POSTPROCESSING #
##################

# Compute the projection operator from the structured mesh to the unstructured mesh (inverse projection)
space, numberings, _offset, _NGauss = PrepareFEComputation(unstructuredRectMesh)
inputFEField = FEField(name="U",mesh=unstructuredRectMesh,space=space,numbering=numberings[0])
method = methods[2]

operator, status = GetFieldTransferOp(inputFEField, unstructuredMesh.nodes, method = method, verbose=True)


# Compute the inverse-projected projected field on the unstructured mesh
inverseProjected_ProjectedU = operator.dot(projectedU)


# Export the unstructured mesh and inverse-projected projected field in xdmf format
writer = XW.XdmfWriter('PostprocessedData.xdmf')
writer.SetHdf5(False)
writer.Open()
writer.Write(unstructuredMesh,PointFields=[inverseProjected_ProjectedU], PointFieldsNames=["U"]);
writer.Close()


##################
# CHECK ACCURACY #
##################

# Create a clippedMesh from the unstructured mesh by removing the left part (x<0)
# (with field, inverse-projected projected field and difference between them) 
from BasicTools.Containers.Filters import ElementFilter
from BasicTools.FE.FETools import ComputePhiAtIntegPoint, ComputeL2ScalarProducMatrix
from BasicTools.Containers.UnstructuredMeshInspectionTools import ExtractElementsByElementFilter
from BasicTools.Containers.UnstructuredMeshModificationTools import CleanLonelyNodes
from BasicTools.Containers.UnstructuredMeshFieldOperations import CopyFieldsFromOriginalMeshToTargetMesh

unstructuredMesh.nodeFields['delta'] = U - inverseProjected_ProjectedU

elFilter = ElementFilter(unstructuredMesh, zone = lambda p: (-p[:,0]))
unstructuredMeshClipped = ExtractElementsByElementFilter(unstructuredMesh,elFilter)
CleanLonelyNodes(unstructuredMeshClipped)
CopyFieldsFromOriginalMeshToTargetMesh(unstructuredMesh,unstructuredMeshClipped)
nbeOfNodes = unstructuredMeshClipped.GetNumberOfNodes()

deltaClippedMesh = unstructuredMeshClipped.nodeFields['delta']


# Compute the L2(Omega) norm of U, InvProjProjU and delta applying numerical quadrature
# from Lagrange P1 finite element integration using three different methods

# Method 1: "by hand" 

integrationWeights, phiAtIntegPoint = ComputePhiAtIntegPoint(unstructuredMeshClipped)

vectDeltaAtIntegPoints = np.empty((2,phiAtIntegPoint.shape[0]))
for i in range(2):
    vectDeltaAtIntegPoints[i] = phiAtIntegPoint.dot(deltaClippedMesh[:,i])

normDeltaMethod1 = np.sqrt(np.einsum('ij,ij,j', vectDeltaAtIntegPoints, vectDeltaAtIntegPoints, integrationWeights, optimize = True))

# Method 2: using the mass matrix

massMatrix = ComputeL2ScalarProducMatrix(unstructuredMeshClipped, 2)

normDeltaMethod2 = np.sqrt(np.dot(deltaClippedMesh.ravel(order='F'), massMatrix.dot(deltaClippedMesh.ravel(order='F'))))

# Method 3: using the weak form engine

from BasicTools.FE.Integration import IntegrateGeneral
from BasicTools.FE.SymWeakForm import GetField, GetTestField
from BasicTools.FE.Spaces.FESpaces import ConstantSpaceGlobal, ConstantSpaceGlobal

U = GetField("U",2)
Tt = GetTestField("T",1)

wf = U.T*U*Tt

space, numberings, _, _ = PrepareFEComputation(unstructuredMeshClipped)
field1 = FEField("U_0",mesh=unstructuredMeshClipped,space=space,numbering=numberings[0], data = deltaClippedMesh[:,0])
field2 = FEField("U_1",mesh=unstructuredMeshClipped,space=space,numbering=numberings[0], data = deltaClippedMesh[:,1])

from BasicTools.FE.DofNumbering import ComputeDofNumbering
numbering = ComputeDofNumbering(unstructuredMeshClipped,ConstantSpaceGlobal)
unkownField = FEField("T",mesh=unstructuredMeshClipped,space=ConstantSpaceGlobal,numbering=numbering)

elFilter = ElementFilter(unstructuredMeshClipped)

K, F = IntegrateGeneral(mesh=unstructuredMeshClipped,
                    wform=wf,
                    constants={},
                    fields=[field1,field2],
                    unkownFields=[unkownField],
                    integrationRuleName="LagrangeP1",
                    elementFilter=elFilter)

normDeltaMethod3 = np.sqrt(F[0])

print("norm Delta using method 1 =", normDeltaMethod1)
print("norm Delta using method 2 =", normDeltaMethod2)
print("norm Delta using method 3 =", normDeltaMethod3)

